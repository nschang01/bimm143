{
  "hash": "8b0204298fc0edf850c61fa9c2348a4d",
  "result": {
    "markdown": "---\ntitle: \"Class 12: Differential Expression Analysis\"\nauthor: \"Nicole Chang\"\nformat: pdf\neditor_options: \n  chunk_output_type: inline\n---\n\n\n# 2. Import countData and colData\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- read.csv(\"airway_scaledcounts.csv\", row.names= 1)\nmetadata <- read.csv(\"airway_metadata.csv\")\nView(counts)\nView(metadata)\n```\n:::\n\n\n> **Q1.** How many genes are in this dataset?\n\nIn this dataset there are 38694 genes\n\n> **Q2.** How many control cell lines do we have?\n\n\n\n\n\nWe have 4 control cell lines.\n\n# 3. Toy differential gene expression\n\n> Q3. How would you make the above code in either approach more robust?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata[,\"dex\"] == \"control\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata[metadata[,\"dex\"]==\"control\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id     dex celltype     geo_id\n1 SRR1039508 control   N61311 GSM1275862\n3 SRR1039512 control  N052611 GSM1275866\n5 SRR1039516 control  N080611 GSM1275870\n7 SRR1039520 control  N061011 GSM1275874\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol <- metadata[metadata[,\"dex\"]==\"control\",]\ncontrol$id\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SRR1039508\" \"SRR1039512\" \"SRR1039516\" \"SRR1039520\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncontrol.counts <- counts[, control$id]\ncontrol.means <- rowMeans(control.counts)\n```\n:::\n\n\n> **Q4.** Follow the same procedure for the `treated` samples (i.e.Â calculate the mean per gene across drug treated samples and assign to a labeled vector called `treated.mean`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata[,\"dex\"] == \"treated\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmetadata[metadata[,\"dex\"]==\"treated\",]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          id     dex celltype     geo_id\n2 SRR1039509 treated   N61311 GSM1275863\n4 SRR1039513 treated  N052611 GSM1275867\n6 SRR1039517 treated  N080611 GSM1275871\n8 SRR1039521 treated  N061011 GSM1275875\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntreated <- metadata[metadata[,\"dex\"]==\"treated\",]\ntreated$id\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SRR1039509\" \"SRR1039513\" \"SRR1039517\" \"SRR1039521\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntreated.counts <- counts[, treated$id]\ntreated.means <- rowMeans(treated.counts)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmeancounts <- data.frame(control.means, treated.means)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolSums(meancounts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncontrol.means treated.means \n     23005324      22196524 \n```\n:::\n:::\n\n\n> **Q5 (a).** Create a scatter plot showing the mean of the treated samples against the mean of the control samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(meancounts[,1], meancounts[,2], xlab = \"Control\", ylab = \"Treated\")\n```\n\n::: {.cell-output-display}\n![](class12_files/figure-pdf/unnamed-chunk-13-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n> Q5 (b). You could also use the **ggplot2** package to make this figure producing the plot below. What **geom\\_?()** function would you use for this plot?\n\npoint\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(data = meancounts) +\n  aes(x =control.means, y =treated.means) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](class12_files/figure-pdf/unnamed-chunk-14-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n> Q6. Try plotting both axes on a log scale. What is the argument to **plot()** that allows you to do this?\n\nlog\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(meancounts[,1], meancounts[,2],log='xy')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in xy.coords(x, y, xlabel, ylabel, log): 15032 x values <= 0 omitted\nfrom logarithmic plot\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in xy.coords(x, y, xlabel, ylabel, log): 15281 y values <= 0 omitted\nfrom logarithmic plot\n```\n:::\n\n::: {.cell-output-display}\n![](class12_files/figure-pdf/unnamed-chunk-15-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlog2(40/20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nTo calculate the log2 of the fold change between treated and control...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeancounts$log2fc <- log2(meancounts$treated.means/ \n                          meancounts$control.means)\n```\n:::\n\n\nTo remove zero values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)\n\nto.rm <- unique(zero.vals[,1])\nmycounts <- meancounts[-to.rm,]\nhead(mycounts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                control.means treated.means      log2fc\nENSG00000000003        900.75        658.00 -0.45303916\nENSG00000000419        520.50        546.00  0.06900279\nENSG00000000457        339.75        316.50 -0.10226805\nENSG00000000460         97.25         78.75 -0.30441833\nENSG00000000971       5219.00       6687.50  0.35769358\nENSG00000001036       2327.00       1785.75 -0.38194109\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nzero.vals <- which(meancounts[,1:2] == 0, arr.ind = TRUE)\nto.rm <- unique(zero.vals[,1])\nmycounts <- meancounts[-to.rm,]\n```\n:::\n\n\n> Q7. What is the purpose of the `arr.ind` argument in the **which()** function call above? Why would we then take the first column of the output and need to call the **unique()** function?\n\nThe purpose is to tell where in the columns and rows where the meancounts have zero counts. The unique() function gets rid of the repetition so that we don't count rows twice.\n\nOverexpressed and underexpressed genes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nup.ind <- mycounts$log2fc > 2\ndown.ind <- mycounts$log2fc < (-2)\n```\n:::\n\n\n> Q8. Using the `up.ind` vector above can you determine how many up regulated genes we have at the greater than 2 fc level?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(up.ind)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nup.ind\nFALSE  TRUE \n21567   250 \n```\n:::\n:::\n\n\nThere are 250 up regulated genes at the greater than 2 fc level.\n\n> Q9. Using the `down.ind` vector above can you determine how many down regulated genes we have at the greater than 2 fc level?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(down.ind)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndown.ind\nFALSE  TRUE \n21450   367 \n```\n:::\n:::\n\n\nThere are 367 down regulated genes at the greater than 2 fc level.\n\n> Q10. Do you trust these results? Why or why not?\n\nWe cannot trust these results because we haven't done a proper statistical analysis on whether these values are significant.\n\n# 4. DESeq2 analysis\n\nFirst step, loading the library\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(DESeq2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: S4Vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: stats4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: BiocGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, intersect, is.unsorted, lapply, Map, mapply,\n    match, mget, order, paste, pmax, pmax.int, pmin, pmin.int,\n    Position, rank, rbind, Reduce, rownames, sapply, setdiff, sort,\n    table, tapply, union, unique, unsplit, which.max, which.min\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'S4Vectors'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: IRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomicRanges\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: GenomeInfoDb\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: SummarizedExperiment\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: MatrixGenerics\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: matrixStats\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'MatrixGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: Biobase\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'Biobase'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncitation('DESeq2')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nTo cite package 'DESeq2' in publications use:\n\n  Love, M.I., Huber, W., Anders, S. Moderated estimation of fold change\n  and dispersion for RNA-seq data with DESeq2 Genome Biology 15(12):550\n  (2014)\n\nA BibTeX entry for LaTeX users is\n\n  @Article{,\n    title = {Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2},\n    author = {Michael I. Love and Wolfgang Huber and Simon Anders},\n    year = {2014},\n    journal = {Genome Biology},\n    doi = {10.1186/s13059-014-0550-8},\n    volume = {15},\n    issue = {12},\n    pages = {550},\n  }\n```\n:::\n:::\n\n\nLet's generate the specific object that DESeq2 needs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndds <- DESeqDataSetFromMatrix(countData = counts,\n                              colData = metadata,\n                              design = ~dex)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nconverting counts to integer mode\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in DESeqDataSet(se, design = design, ignoreRank): some variables in\ndesign formula are characters, converting to factors\n```\n:::\n\n```{.r .cell-code}\ndds\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: DESeqDataSet \ndim: 38694 8 \nmetadata(1): version\nassays(1): counts\nrownames(38694): ENSG00000000003 ENSG00000000005 ... ENSG00000283120\n  ENSG00000283123\nrowData names(0):\ncolnames(8): SRR1039508 SRR1039509 ... SRR1039520 SRR1039521\ncolData names(4): id dex celltype geo_id\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndds <- DESeq(dds)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nestimating size factors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nestimating dispersions\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\ngene-wise dispersion estimates\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nmean-dispersion relationship\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nfinal dispersion estimates\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nfitting model and testing\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- results(dds)\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlog2 fold change (MLE): dex treated vs control \nWald test p-value: dex treated vs control \nDataFrame with 38694 rows and 6 columns\n                 baseMean log2FoldChange     lfcSE      stat    pvalue\n                <numeric>      <numeric> <numeric> <numeric> <numeric>\nENSG00000000003  747.1942     -0.3507030  0.168246 -2.084470 0.0371175\nENSG00000000005    0.0000             NA        NA        NA        NA\nENSG00000000419  520.1342      0.2061078  0.101059  2.039475 0.0414026\nENSG00000000457  322.6648      0.0245269  0.145145  0.168982 0.8658106\nENSG00000000460   87.6826     -0.1471420  0.257007 -0.572521 0.5669691\n...                   ...            ...       ...       ...       ...\nENSG00000283115  0.000000             NA        NA        NA        NA\nENSG00000283116  0.000000             NA        NA        NA        NA\nENSG00000283119  0.000000             NA        NA        NA        NA\nENSG00000283120  0.974916      -0.668258   1.69456 -0.394354  0.693319\nENSG00000283123  0.000000             NA        NA        NA        NA\n                     padj\n                <numeric>\nENSG00000000003  0.163035\nENSG00000000005        NA\nENSG00000000419  0.176032\nENSG00000000457  0.961694\nENSG00000000460  0.815849\n...                   ...\nENSG00000283115        NA\nENSG00000283116        NA\nENSG00000283119        NA\nENSG00000283120        NA\nENSG00000283123        NA\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(res, alpha = 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nout of 25258 with nonzero total read count\nadjusted p-value < 0.05\nLFC > 0 (up)       : 1242, 4.9%\nLFC < 0 (down)     : 939, 3.7%\noutliers [1]       : 142, 0.56%\nlow counts [2]     : 9971, 39%\n(mean count < 10)\n[1] see 'cooksCutoff' argument of ?results\n[2] see 'independentFiltering' argument of ?results\n```\n:::\n:::\n\n\n# 6. Data Visualization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(res$log2FoldChange, -log(res$padj),\n     xlab=\"Log2(FoldChange)\",\n     ylab=\"-Log(P-value)\")\n```\n\n::: {.cell-output-display}\n![](class12_files/figure-pdf/unnamed-chunk-29-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot( res$log2FoldChange,  -log(res$padj), \n ylab=\"-Log(P-value)\", xlab=\"Log2(FoldChange)\")\n\n# Add some cut-off lines\nabline(v=c(-2,2), col=\"darkgray\", lty=2)\nabline(h=-log(0.05), col=\"darkgray\", lty=2)\n```\n\n::: {.cell-output-display}\n![](class12_files/figure-pdf/unnamed-chunk-30-1.pdf){fig-pos='H'}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Setup our custom point color vector \nmycols <- rep(\"gray\", nrow(res))\nmycols[ abs(res$log2FoldChange) > 2 ]  <- \"red\" \n\ninds <- (res$padj < 0.01) & (abs(res$log2FoldChange) > 2 )\nmycols[ inds ] <- \"blue\"\n\n# Volcano plot with custom colors \nplot( res$log2FoldChange,  -log(res$padj), \n col=mycols, ylab=\"-Log(P-value)\", xlab=\"Log2(FoldChange)\" )\n\n# Cut-off lines\nabline(v=c(-2,2), col=\"gray\", lty=2)\nabline(h=-log(0.1), col=\"gray\", lty=2)\n```\n\n::: {.cell-output-display}\n![](class12_files/figure-pdf/unnamed-chunk-31-1.pdf){fig-pos='H'}\n:::\n:::\n",
    "supporting": [
      "class12_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}